/*
 * Unitex
 *
 * Copyright (C) 2001-2011 Université Paris-Est Marne-la-Vallée <unitex@univ-mlv.fr>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2.1 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.
 *
 */

#include "LocateMatches.h"
#include "Error.h"



/**
 * Allocates, initializes and returns a new match list element.
 */
struct match_list* new_match(int start,int end,unichar* output,struct match_list* next,Abstract_allocator prv_alloc) {
return new_match(start,end,-1,-1,-1,-1,output,next,prv_alloc);
}


/**
 * Allocates, initializes and returns a new match list element.
 */
struct match_list* new_match(int start,int end,int start_char,int end_char,
                             int start_letter,int end_letter,unichar* output,struct match_list* next,Abstract_allocator prv_alloc) {
struct match_list *l;
l=(struct match_list*)malloc_cb(sizeof(struct match_list),prv_alloc);
if (l==NULL) {
   fatal_alloc_error("new_match");
}
l->m.start_pos_in_token=start;
l->m.end_pos_in_token=end;
if (output==NULL) {
   l->output=NULL;
} else {
   l->output=u_strdup(output,prv_alloc);
}
l->m.start_pos_in_char=start_char;
l->m.end_pos_in_char=end_char;
l->m.start_pos_in_letter=start_letter;
l->m.end_pos_in_letter=end_letter;
l->next=next;
return l;
}


/**
 * Frees a single match list element.
 */
void free_match_list_element(struct match_list* l,Abstract_allocator prv_alloc) {
if (l==NULL) return;
if (l->output!=NULL) free_cb(l->output,prv_alloc);
free_cb(l,prv_alloc);
}


/**
 * Frees a single match list element.
 */
void free_match_list(struct match_list* l,Abstract_allocator prv_alloc) {
while (l!=NULL) {
   struct match_list* ptr=l;
   l=l->next;
   if (ptr->output!=NULL) free_cb(ptr->output,prv_alloc);
   free_cb(ptr,prv_alloc);
}
}




/**
 * Loads a match list. Match lists are supposed to have been
 * generated by the Locate program.
 */
struct match_list* load_match_list(U_FILE* f,OutputPolicy *output_policy,Abstract_allocator prv_alloc) {
struct match_list* l=NULL;
struct match_list* end_of_list=NULL;
int start,end,start_char,end_char,start_letter,end_letter;
unichar output[3000];
char is_an_output;
/* We read the header */
unichar uc_policy=0;
u_fscanf(f,"#%C\n",&uc_policy);
OutputPolicy policy;
switch(uc_policy) {
   case 'M': policy=MERGE_OUTPUTS; break;
   case 'R':
   case 'T': policy=REPLACE_OUTPUTS; break;
   case 'I':
   default: policy=IGNORE_OUTPUTS; break;
}
if (output_policy!=NULL) {
   (*output_policy)=policy;
}
while (6==u_fscanf(f,"%d.%d.%d %d.%d.%d",&start,&start_char,&start_letter,&end,&end_char,&end_letter)) {
   /* We look if there is an output or not, i.e. a space or a new line */
   int c=u_fgetc(f);
   if (c==' ') {
      /* If we have an output to read */
      int i=0;
      while ((c=u_fgetc(f))!='\n') {
         output[i++]=(unichar)c;
      }
      output[i]='\0';
   }
   is_an_output=(policy!=IGNORE_OUTPUTS);
   if (l==NULL) {
      l=new_match(start,end,start_char,end_char,start_letter,end_letter,is_an_output?output:NULL,NULL,prv_alloc);
      end_of_list=l;
   } else {
      end_of_list->next=new_match(start,end,start_char,end_char,start_letter,end_letter,is_an_output?output:NULL,NULL,prv_alloc);
      end_of_list=end_of_list->next;
   }
}
return l;
}


